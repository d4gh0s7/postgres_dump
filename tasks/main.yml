---
# tasks file for postgres_dump.

- name: Determine the running postgresql version
  shell: psql -V | egrep -o '[0-9]{1,}\.[0-9]{1,}' # Major.Minor version
  register: pg_version
  changed_when: No

- name: Save the postgresql version
  set_fact:
    postgresql_version: "{{ pg_version.stdout }}"
  when: pg_version and postgresql_version == 0

- name: Check the postgresql service state
  block:
  - name: Collect facts about system services
    service_facts:
    register: services_state

  - name: Determine if postgresql-{{ postgresql_version }} is running
    assert:
      that: services_state.ansible_facts.services['postgresql-{{ postgresql_version }}.service'].state == "running"

  - name: Provision a temporary unprivileged user
    block:
    - name: Generate a random username
      shell: echo $RANDOM | tr '[0-9]' '[a-zA-Z]'
      register: random_username

    - name: Generate a random string
      command: openssl rand -base64 24
      register: random_string

    - name: Create the temporary user
      command: createuser --no-password -S -D {{ random_username.stdout }}
      register: postgresql_termporary_user_created

    - name: Secure the temporary user access
      command: psql --command="ALTER USER {{ random_username.stdout }} WITH PASSWORD '{{ random_string.stdout }}';"

    - name: Set the temporary user as postgresql_backup_executor
      set_fact:
        postgresql_backup_executor: "{{ random_username.stdout }}"

    - name: Grant privileges to the temporary user
      command: psql --command="{{ item }}";
      loop: "{{ postgresql_provision_temporary_user_grant_privileges_commands }}"

    no_log: Yes
    become: Yes
    become_user: postgres
    when: postgresql_provision_temporary_user

  when: postgresql_check_service_state or postgresql_provision_temporary_user

- name: Set the full path to store the database backup
  set_fact:
    postgresql_dump_fullpath: "{{ postgresql_base_folder }}/{{ postgresql_version }}/backups"

- name: Store the backup path in a variable
  stat:
    path: "{{ postgresql_dump_fullpath }}"
  register: pg_backups_path

- name: Determine if the backups directory path exists
  assert:
    that: pg_backups_path.stat.exists and pg_backups_path.stat.isdir

- name: Execute the full database dump with pg_dumpall
  become: Yes
  become_user: "{{ postgresql_backup_owner }}"
  command: |
     pg_dumpall {% for command_flag in postgresql_dumpall_params %} {{ command_flag }} {% endfor %} \
     -U {{ postgresql_backup_executor }} \
     --no-password \
     --file {{ postgresql_dump_filename }}
  args:
    chdir: "{{ postgresql_dump_fullpath }}"
  changed_when: No
  when: not postgresql_provision_temporary_user

- name: Save the postgresql_backup_log_file path and name in a variable
  set_fact:
    postgresql_backup_log_file: "{{ postgresql_dump_fullpath }}/{{ postgresql_dump_filename }}.log"

- name: Log the postgresql_backup_executor to the file system
  lineinfile:
    create: Yes
    path: "{{ postgresql_backup_log_file }}"
    line: "pg_dumpall executed by {{ postgresql_backup_executor }}"
    owner: "{{ postgresql_backup_owner }}"
    group: "{{ postgresql_backup_owner }}"
    mode: 0400

- name: Run pg_dumpall as temporary_user
  block:
  - name: Execute the full database dump as temporary user
    expect:
      command: pg_dumpall {% for command_flag in postgresql_dumpall_params %} {{ command_flag }} {% endfor %}
        -h 127.0.0.1 -U {{ postgresql_backup_executor }}
        -W --file {{ postgresql_dump_filename }}
      chdir: "{{ postgresql_dump_fullpath }}"
      responses:
        Password: "{{ random_string.stdout }}"
    changed_when: No

  - name: Revoke the privileges from the temporary user
    command: psql --command="{{ item }};"
    loop: "{{ postgresql_provision_temporary_user_revoke_privileges_commands }}"

  - name: Drop the temporary user
    command: dropuser "{{ postgresql_backup_executor }}"

  no_log: Yes
  become: Yes
  become_user: "{{ postgresql_backup_owner }}"
  when: postgresql_provision_temporary_user

- name: Determine the sha256 checksum of the database full dump file
  stat:
    path: "{{ postgresql_dump_fullpath }}/{{ postgresql_dump_filename }}"
    checksum_algorithm: sha256
    get_checksum: Yes
  register: postgres_dump_info

- name: Determine a file path and a name to store the sha256 checksum
  set_fact:
    checksum_file: "{{ postgresql_dump_fullpath }}/{{ postgresql_dump_filename }}.sha256_checksum"
  when: postgres_dump_info

- name: Save the sha256 checksum to the file system
  lineinfile:
    create: Yes
    path: "{{ checksum_file }}"
    line: "{{ postgres_dump_info.stat.checksum }} {{ postgresql_dump_filename }}"
    owner: "{{ postgresql_backup_owner }}"
    group: "{{ postgresql_backup_owner }}"
    mode: 0400

- name: Run the sha256 checksum validation
  command: sha256sum --check {{ checksum_file }}
  args:
    chdir: "{{ postgresql_dump_fullpath }}"
  register: checksum_validation
  changed_when: No

- name: Verify the backup sha256 checksum as PoC
  assert:
    that:
     - "'OK' in checksum_validation.stdout"

- name: Create a compressed archive of the database full dump
  archive:
    path:
      - "{{ postgresql_dump_fullpath }}/{{ postgresql_dump_filename }}"
      - "{{ checksum_file }}"
      - "{{ postgresql_backup_log_file }}"
    dest: "{{ postgresql_dump_fullpath }}/{{ postgresql_dump_filename }}.gz"
    owner: "{{ postgresql_backup_owner }}"
    group: "{{ postgresql_backup_owner }}"
    mode: 0400
    remove: "{{ postgresql_cleanup_after_backup }}"
    format: gz
  register: postgresql_dump_stored

- name: List the archived files
  debug:
    var: postgresql_dump_stored.archived
...
